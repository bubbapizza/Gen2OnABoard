/* Main header file for FiveD firmware.  Generated by makeheaders
   command. */

extern FloatPoint where_i_am;
extern cartesian_dda *cdda[BUFFER_SIZE];
extern volatile byte tail;
extern volatile byte head;
extern word interruptBlink;
extern bool led;
#if !(MOTHERBOARD < 2)
   extern intercom talker;
#endif
extern char debugstring[100];
extern byte extruder_in_use;
extern extruder *ex[EXTRUDER_COUNT];
extern byte serial_count;
extern boolean comment;


byte getTimerResolution(const long&delay);
void delayMicrosecondsInterruptible(unsigned int us);
unsigned int getTimerCeiling(const long&delay);
void setTimerResolution(byte r);
void loop();
void shutdown();
void setupTimerInterrupt();
void setup();
void blink();
void setupGcodeProcessor();
void get_and_do_command();
ISR(TIMER1_COMPA_vect);


// INLINE FUNCTIONS
#include "global.h"

inline void setPosition(const FloatPoint&p){
  where_i_am = p;  
};


inline bool qFull(){
  if(tail == 0)
    return head == (BUFFER_SIZE - 1);
  else
    return head == (tail - 1);
};


inline void qMove(const FloatPoint&p){
  while(qFull())
  {
    manageAllExtruders();
    delay(WAITING_DELAY);
  }
  byte h = head; 
  h++;
  if(h >= BUFFER_SIZE)
    h = 0;
  cdda[h]->set_target(p);
  head = h;
};


inline bool qEmpty(){
   return tail == head && !cdda[tail]->active();
};


inline void cancelAndClearQueue(){
	tail = head;	// clear buffer
	for(int i=0;i<BUFFER_SIZE;i++)
		cdda[i]->kill();
};


// Depending on how much work the interrupt function has to do, this is
// pretty accurate between 10 us and 0.1 s.  At fast speeds, the time
// taken in the interrupt function becomes significant, of course.

// Note - it is up to the user to call enableTimerInterrupt() after a call
// to this function.

inline void setTimer(long delay){
	// delay is the delay between steps in microsecond ticks.
	//
	// we break it into 5 different resolutions based on the delay. 
	// then we set the resolution based on the size of the delay.
	// we also then calculate the timer ceiling required. (ie what the counter counts to)
	// the result is the timer counts up to the appropriate time and then fires an interrupt.

        // Actual ticks are 0.0625 us, so multiply delay by 16
        
        delay <<= 4;
        
	setTimerCeiling(getTimerCeiling(delay));
	setTimerResolution(getTimerResolution(delay));
};


inline void dQMove(){
  if(qEmpty())
    return;
  byte t = tail;  
  t++;
  if(t >= BUFFER_SIZE)
    t = 0;
  cdda[t]->dda_start();
  tail = t; 
};


inline void init_process_string(){
	serial_count = 0;
  comment = false;
};
